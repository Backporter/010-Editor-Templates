//--------------------------------------
//--- 010 Editor v3.0.5 Binary Template
//
// File: modo .lx* template parser
// Author: Gwynne Reddick
// Revision: 1.00
// Purpose: Reads all known chunks in modo *.lxo, *.lxp. *.lxe and *.lxl files
//--------------------------------------

local int haveValidFormat = false;
local ulong numTriSurfVerts; // stores num of verts in 3SRF chunk for use by VRTS chunk
local ulong numTriSurfTris; // stores num of tris in 3SRF chunk for use by TRIS chunk
local ulong numTriSurfTags; // stores num of tags in 3SRF chunk for use by TTGS chunk

// Typedefs for the IFF file
typedef char ID[4];
typedef ulong CSIZE;  // Chunk size
typedef ushort SCSIZE; // Subchunk size


// chunks
struct IFFHEADER;
struct PSCR_CHUNK;
struct VRSN_CHUNK;
struct DESC_CHUNK;
struct PRVW_CHUNK;
struct THUM_CHUNK;
struct ENCO_CHUNK;
struct STAG_CHUNK;
struct TAGS_CHUNK;
struct PRNT_CHUNK;
struct ITEM_CHUNK;
struct ENVL_CHUNK;
struct ACTN_CHUNK;
struct CHNM_CHUNK;
struct REFS_CHUNK;
struct LAYR_CHUNK;
struct PNTS_CHUNK;
struct BBOX_CHUNK;
struct VMPA_CHUNK;
struct VMAP_CHUNK;
struct POLS_CHUNK;
struct VMAD_CHUNK;
struct VMED_CHUNK;
struct PTAG_CHUNK;
struct _3GRP_CHUNK;
struct _3SRF_CHUNK;
struct VRTS_CHUNK;
struct TRIS_CHUNK;
struct VVEC_CHUNK;
struct TTGS_CHUNK;
struct AUTH_CHUNK;
struct CPYR_CHUNK;
struct ANNO_CHUNK;
struct AANI_CHUNK;
struct BAKE_CHUNK;

// misc
struct RGBA;
struct POINT;
struct VERTINDEX;
struct VERTDATA;

// unrecognized chunk/subchunk
struct UNKNOWNCHUNK;

// subchunk reading functions
void readsubchunks(int pos);


enum {              // Item Data Types
    LXItemType_Int              = 0x01,
    LXItemType_Float            = 0x02,
    LXItemType_String           = 0x03,
    LXItemType_Variable         = 0x04,
    LXItemType_Envelope         = 0x10,
    LXItemType_UndefState       = 0x20,     // undefined action channel

    LXItemType_EnvelopeInt      = LXItemType_Envelope | LXItemType_Int,
    LXItemType_EnvelopeFloat    = LXItemType_Envelope | LXItemType_Float,
    LXItemType_EnvelopeString   = LXItemType_Envelope | LXItemType_String,

    LXItemType_FloatAlt         = 0x4e56,   // compatibility with some apps

    LXEnvelopeType_Float        = 0,
    LXEnvelopeType_Int          = 1,
    };



//------------------------------------------------------------
// File gets processed here
//------------------------------------------------------------

BigEndian(); 
SetBackColor( 0x6BC040 );
IFFHEADER header;


// Check for valid header
if( header.groupID != "FORM")
{
    Warning( "File is not a valid IFF file. Template stopped." );
    return -1;
}

switch (header.iffType) {
    case "LXPR":
        break;
    case "LXPE":
        break;
    case "LXOB":
        break;
    case "LXPM":
        break;
    default:
        Warning( "File is not a recognised modo file. Template stopped." );
        return -1;
}


// Read the file as a set of chunks
local ID tag;
local uint size;
while( !FEof() )
{
    // Read the chunk tag 
    ReadBytes( tag, FTell(), 4 );
    // See which chunk this is
    switch( tag )
    {
        case "PSCR":
            SetBackColor( cLtPurple );
            PSCR_CHUNK   PSCR;
            break;
        case "DESC":
            SetBackColor( cLtPurple );
            DESC_CHUNK   DESC;
            break;
        case "PRVW":
            SetBackColor( cNone );
            PRVW_CHUNK   PRVW;
            break;
        case "VRSN":
            SetBackColor( 0x2AD4FF );
            VRSN_CHUNK   VRSN;
            break;
        case "ENCO":
            SetBackColor( cLtPurple );
            ENCO_CHUNK  ENCO;
            break;
        case "STAG":
            SetBackColor( cLtPurple );
            STAG_CHUNK  STAG;
            break;
        case "THUM":
            SetBackColor( cNone );
            THUM_CHUNK   THUM;
            break;
        case "PRNT":
            SetBackColor( cLtGray );
            PRNT_CHUNK   PRNT;
            break;
        case "ITEM":
            SetBackColor( 0x406BC0 );
            ITEM_CHUNK   ITEM;
            break;
        case "ENVL":
            SetBackColor( cLtGreen );
            ENVL_CHUNK   ENVL;
            break;
        case "ACTN":
            SetBackColor( cLtGreen );
            ACTN_CHUNK   ACTN;
            break;
        case "TAGS":
            SetBackColor( 0xE1E1E1 );
            TAGS_CHUNK   TAGS;
            break;
        case "REFS":
            SetBackColor( 0xE1E1E1 );
            REFS_CHUNK   REFS;
            break;
        case "CHNM":
            SetBackColor( 0xFFAAAA );
            CHNM_CHUNK   CHNM;
            break;
        case "LAYR":
            SetBackColor( 0xFFAAD4 );
            LAYR_CHUNK   LAYR;
            break;
        case "PNTS":
            SetBackColor( 0xFFD4AA );
            PNTS_CHUNK   PNTS;
            break;
        case "BBOX":
            SetBackColor( 0xFFAA2A );
            BBOX_CHUNK   BBOX;
            break;
        case "VMPA":
            SetBackColor( cLtGreen );
            VMPA_CHUNK   VMPA;
            break;
        case "VMAP":
            SetBackColor( cLtGreen );
            VMAP_CHUNK   VMAP;
            break;
        case "POLS":
            SetBackColor( 0xD4D4FF );
            POLS_CHUNK   POLS;
            break;
        case "VMAD":
            SetBackColor( cLtGreen );
            VMAD_CHUNK   VMAD;
            break;
        case "VMED":
            SetBackColor( cLtGreen );
            VMAD_CHUNK   VMAD;
            break;
        case "PTAG":
            SetBackColor( 0x6BC040 );
            PTAG_CHUNK   PTAG;
            break;
        case "3GRP":
            SetBackColor( cLtGreen );
            _3GRP_CHUNK   _3GRP;
            break;
        case "3SRF":
            SetBackColor( cLtGreen );
            _3SRF_CHUNK   _3SRF;
            break;
        case "VRTS":
            SetBackColor( cLtGreen );
            VRTS_CHUNK   VRTS;
            break;
        case "TRIS":
            SetBackColor( cLtGreen );
            TRIS_CHUNK   TRIS;
            break;
        case "VVEC":
            SetBackColor( cLtGreen );
            VVEC_CHUNK   VVEC;
            break;
        case "TTGS":
            SetBackColor( cLtGreen );
            TTGS_CHUNK   TTGS;
            break;
        case "AUTH":
            SetBackColor( cLtGreen );
            AUTH_CHUNK   AUTH;
            break;
        case "(c) ":
            SetBackColor( cLtGreen );
            CPYR_CHUNK   CPYR;
            break;
        case "ANNO":
            SetBackColor( cLtGreen );
            ANNO_CHUNK   ANNO;
            break;
        case "BAKE":
            SetBackColor( cLtGreen );
            BAKE_CHUNK  BAKE;
            break;
        case "AANI":
            SetBackColor( cLtGreen );
            AANI_CHUNK  AANI;
            break;
        default:
            // Unknown chunk
            if ( FTell() < header.size ){
                size = ReadUInt( FTell()+4 );
                Printf( "Encountered unknown chunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
                SetBackColor( cNone );
                UNKNOWNCHUNK unknown;
            }
            break;
    }
}



//------------------------------------------------------------
// File header chunk
//------------------------------------------------------------
typedef struct 
{
    ID     groupID;
    long   size;
    ID     iffType;
} IFFHEADER <name="IFF Header", read=IFFHEADER_Read>;

string IFFHEADER_Read(IFFHEADER &header) {
    string  ext;
    switch (header.iffType) {
        case "LXPR":
            ext = " (.lxp)";
            break;
        case "LXPE":
            ext = " (.lxe)";
            break;
        case "LXOB":
            ext = " (.lxo)";
            break;
        case "LXPM":
            ext = " (.lxl)";
            break;
        default:
            ext = "Unknown";
    }
    SPrintf( ext, header.iffType + ext );
    return  ext;
}



//------------------------------------------------------------
// Chunk definitions.
//------------------------------------------------------------

// PSCR chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    string          scriptpath<name="Script Path   ">;
    if (sizeof(scriptpath) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PSCR_CHUNK <name="PSCR Chunk   ", read=PSCR_CHUNKRead>;

string PSCR_CHUNKRead(PSCR_CHUNK &pscr) {
    return pscr.scriptpath;
}


// DESC chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    string          type<name="Type   ">;
    if (sizeof(type) & 1)
        uchar padding <hidden=true>;
    string    text<name="Text   ">;
    if (sizeof(text) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} DESC_CHUNK <read=DESC_CHUNKRead, name="DESC Chunk   ">;

string DESC_CHUNKRead(DESC_CHUNK &desc) {
    return desc.type;
}


// THUM chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    char            thumbData[size]<name="Thumbnail Image Data">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} THUM_CHUNK <name="THUM Chunk   ">;


// PRVW chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int pos = FTell();
    unsigned short  width<name="Width">;
    unsigned short  height<name="Height">;
    unsigned long   type<name="Type">;
    unsigned long   flags<format=binary, name="Flags">; 
    char            previewData[size - (FTell() - pos)]<name="Preview Image Data   ">;
    

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PRVW_CHUNK <read=PRVW_CHUNKRead, name="PRVW Chunk   ">;

string PRVW_CHUNKRead(PRVW_CHUNK &prvw) {
    string s;
    return SPrintf(s, "width: %d height: %d", prvw.width, prvw.height);
}


// VRSN chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ulong           majorVersion<name="Major Version">;
    ulong           minorVersion<name="Minor Version">;
    string          application<name="Application   ">;
    if (sizeof(application) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VRSN_CHUNK <read=VRSN_CHUNKRead, name="VRSN Chunk   ">;

string VRSN_CHUNKRead(VRSN_CHUNK &version) {
    return version.application;
}


// PRNT chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int pos = FTell();
    string          parent<name="Parent   ">;
    if (sizeof(parent) & 1)
        uchar padding <hidden=true>;
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PRNT_CHUNK <name="PRNT Chunk   ">;



// ENCO chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    unsigned long   encoding<name="Encoding">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENCO_CHUNK <name="ENCO Chunk   ">;


// STAG chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ID              tag<name="Tag ID   ">;
    string          file<name="Filename   ">;
    if (sizeof(file) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} STAG_CHUNK <read=STAG_CHUNKRead, name="STAG Chunk   ">;

string STAG_CHUNKRead(STAG_CHUNK &stag) {
    string s;
    SPrintf(s, "%s", stag.file);
    return  s;
}


// ITEM chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    string          type<name="Type   ">;
    if (sizeof(type) & 1)
        uchar padding <hidden=true>;

    string          username<name="UserName   ">;
    if (sizeof(username) & 1)
        uchar padding <hidden=true>;

    ulong   id<name="ID">;
    local int subchunks = FTell();
    // Read the subchunks
    while( FTell() - pos < size )
        readITEMsubchunks(subchunks);
    
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHUNK <read=ITEM_CHUNKRead, name="ITEM Chunk   ">;

string ITEM_CHUNKRead(ITEM_CHUNK &chunk) {
    string s;
    SPrintf(s, "Type: %s   Username: %s ", chunk.type, chunk.username);
    return  s;
}


// ENVL chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    local ushort    tmpIndex;
    tmpIndex = ReadUShort(FTell());
    if (tmpIndex < 0xFF00)
        ushort      index<name="Index">;
    else
        ulong       index<name="Index">;
    ulong           type<name="Type   ">;
    local int subchunks = FTell();
    while( FTell() - pos < size )
        readENVLsubchunks(subchunks);

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_CHUNK <name="ENVL Chunk   ">;


// ACTN chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;

    string          type<name="Type   ">;
    if (sizeof(type) & 1)
        uchar padding <hidden=true>;

    ulong           identifier<name="Identifier">;
    //ushort   flags;
    local int subchunks = FTell();
    while( FTell() - pos < size )
        readACTNsubchunks(subchunks);

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHUNK <read=ACTN_CHUNKRead, name="ACTN Chunk   ">;

string ACTN_CHUNKRead(ACTN_CHUNK &actn) {
    string s;
    SPrintf(s, "Type: %s   Name: %s ", actn.type, actn.name);
    return  s;
}


// TAGS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();

    typedef struct {
        string      tagname<name="Tag Name   ">;
        if (sizeof(tagname) & 1)
            uchar padding <hidden=true>;
    } TAGNAME <read=TAGNAME_Read>;

    while( FTell() - pos < size )
        TAGNAME  tag<name="Tag   ">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} TAGS_CHUNK <name="TAGS Chunk   ">;

string TAGNAME_Read(TAGNAME &tag) {
    return tag.tagname;
}


// CHNM chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ulong           channels<name="Channels">;
    typedef struct {
        string      name<name="Name   ">;
        if (sizeof(name) & 1)
            uchar padding <hidden=true>;
    } CHANNEL <read=CHANNEL_Read, name="Channel Name   ">;
    while( FTell() - pos < size )
        CHANNEL     name;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} CHNM_CHUNK <name="CHNM Chunk   ">;

string CHANNEL_Read(CHANNEL &chan) {
    return chan.name;
}


// REFS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ulong           refscount<name="Refs Count">;
    typedef struct {
        string          filepath<name="File">;
        if (sizeof(filepath) & 1)
            uchar padding <hidden=true>;
    } FILESPEC <read=FILESPEC_Read>;
    local int i;
    for( i=0; i<refscount; i++ )
        FILESPEC  ref;
    local int subchunks = FTell();
    while( FTell() - pos < size )
        readREFSsubchunks(subchunks);
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} REFS_CHUNK <name="REFS Chunk   ">;

string FILESPEC_Read(FILESPEC &ref) {
    return ref.filepath;
}


// LAYR chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ushort          legacyIndex<name="(legacy) Index">;
    ushort          flags<format=binary, name="Flags">; 
    POINT           rotationPivot<name="Rotation Pivot">;
    string          layerName<name="Layer Name   ">;
    if (sizeof(layerName) & 1)
        uchar padding <hidden=true>;
    ushort          legacyParentIndex<name="(legacy) Parent Index">;
    float           subdivRefineLevel<name="Subdiv Refinement Level">;
    float           freezeCurveRefineLevel<name="Curve Refinement Level">;
    POINT           scalePivot<name="Scale Pivot">;
    ulong           unusedU4[6]<name="Reserved   ">;
    ulong           itemReference<name="Item Reference">;
    ushort          splineRefineLevel<name="Spline Refinement Level">;
    ushort          unusedU2[3]<name="Unused   ">;
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} LAYR_CHUNK <read=LAYR_CHUNKRead, name="LAYR Chunk   ">;

string LAYR_CHUNKRead(LAYR_CHUNK &layr) {
    string s;
    SPrintf( s, "LAYR name: %s", layr.layerName );
    return s;
}


// PNTS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    POINT           points[size/12]<name="Points   ">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PNTS_CHUNK <read=PNTS_CHUNKRead, name="PNTS Chunk   ">;

string PNTS_CHUNKRead(PNTS_CHUNK &pnts) {
    string s;
    SPrintf( s, "Num Points: %d", pnts.size/12 );
    return s;
}


// BBOX chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    POINT           min<name="Min">;
    POINT           max<name="Max">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} BBOX_CHUNK <read=BBOX_CHUNKRead, name="BBOX Chunk   ">;

string BBOX_CHUNKRead(BBOX_CHUNK &bbox) {
    string s;
    return SPrintf( s, "(%s), (%s)", POINT_Read(bbox.min), POINT_Read(bbox.max) );
}


// VMPA chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ulong           flags1<format=binary, name="Flags 1">; 
    ulong           flags2<format=binary, name="Flags 2">; 
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMPA_CHUNK <read=VMPA_CHUNKRead, name="VMPA Chunk   ">;

string VMPA_CHUNKRead(VMPA_CHUNK &vmpa) {
    string s;
    SPrintf( s, "%d, %d", vmpa.flags1, vmpa.flags2 );
    return s;
}


// VMAP chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Map Type   ">;
    ushort          dimension<name="Dimension">;
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    typedef struct {
        local ushort tmpIndex;
        tmpIndex = ReadUShort(FTell());
        if (tmpIndex < 0xFF00)
            ushort  index;
        else
            ulong   index;
        float           values[dimension];
    } VERT;
    while( FTell() - pos < size )
        VERT     vertex;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMAP_CHUNK <read=VMAP_CHUNKread, name="VMAP Chunk   ">;

string VMAP_CHUNKread(VMAP_CHUNK &vmap) {
    string s;
    SPrintf( s, "Type: %s   Name: %s", vmap.type, vmap.name );
    return s;
}


// POLS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Poly Type   ">;
    
    
    typedef struct{
        local ushort tmpIndex;
        tmpIndex = ReadUShort(FTell());
        if (tmpIndex < 0xFF00)
            ushort  index;
        else
            ulong   index;
    }VERTINDEX<name="Index", read=VERTINDEX_Read>;

    while( FTell() - pos < size ){
        ushort nverts;
        if ("CURV" == type || "BEZR" == type) {
            ulong flags = (nVerts & 0xfc00) >> 10;        // get curve flags
            nVerts &= 0x3ff;                        // mask off curve flags
            }
        else if ("HCRV" == type || "BCRV"  == type) {
            ulong flags;
            VERTINDEX vertIndex[nverts] <optimize=false>;
            break;
            }
        if ("CURV" == type || "BEZR" == type)
            if (nVerts < 4 || 1 != (nVerts % 3))        // Skip invalid bezier curves
                continue;
        VERTINDEX vertIndex[nverts] <optimize=false>;
     }
        
        
        

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} POLS_CHUNK <name="POLS Chunk   ">;

string VERTINDEX_Read(VERTINDEX &index){
    string s;
    return SPrintf(s, "%d", (int)index.index);
}


// VMAD chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Type   ">;
    ushort          dimension<name="Dimension">;
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    
    while( FTell() - pos < size )
        VERTDATA    data;
    
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMAD_CHUNK <read=VMAD_CHUNKread, name="VMAD Chunk   ">;

string VMAD_CHUNKread(VMAD_CHUNK &vmad){
    string s;
    return SPrintf(s, "Type: %s   Name: %s", vmad.type, vmad.name);
}


// VMED chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ID              type<name="Type   ">;
    ushort          dimension<name="Dimension">;
    string          name<name="Name   ">;
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    
    while( FTell() - pos < size )
        VERTDATA    data;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VMED_CHUNK <read=VMED_CHUNKread, name="VMED Chunk   ">;

string VMED_CHUNKread(VMED_CHUNK &vmed){
    string s;
    return SPrintf(s, "Type: %s   Name: %s", vmed.type, vmed.name);
}


// PTAG chunk
typedef struct{
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Type">;
    while( FTell() - pos < size )
        struct {
            local ushort tmpIndex;
            tmpIndex = ReadUShort(FTell());
            if (tmpIndex < 0xFF00)
                ushort  polyIndex;
            else
                ulong   polyIndex;
            ushort      tagIndex;
        }PTAGDATA<name="PTAG   ">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} PTAG_CHUNK <read=PTAG_CHUNKRead, name="PTAG Chunk   ">;

string PTAG_CHUNKRead(PTAG_CHUNK &ptag) {
    string s;
    return SPrintf( s, "Type: %s", ptag.type );
}


// 3GRP chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ulong           numTriSurfs<name="Trisurf Count">;
    ulong           itemReference<name="Item Ref">;
    ulong           flags<format=binary, name="Flags">; 
     // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} _3GRP_CHUNK <name="3GRP Chunk   ">;


// 3SRF chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ulong           numVerts<name="Num Verts">;
    numTriSurfVerts = numVerts;
    ulong           numTris<name="Num Tris">;
    numTriSurfTris = numTris;
    ulong           numVVEC<name="Num VVEC">;
    ulong           numTags<name="Num Tags">;
    numTriSurfTags = numTags;
    ulong           flags<format=binary, name="Flags">; 

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} _3SRF_CHUNK <name="3SRF Chunk   ">;


// VRTS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    POINT           verts[numTriSurfVerts]<name="Verts   ">;
     // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VRTS_CHUNK <read=VRTS_CHUNKread, name="VRTS Chunk   ">;

string VRTS_CHUNKread(VRTS_CHUNK &vrts) {
    string  s;
    return SPrintf(s, "%d Verts", numTriSurfVerts);
}


// TRIS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    struct tri {
        ulong   vertA;
        ulong   vertB;
        ulong   vertC;
    };
    tri        triangles[numTriSurfTris]<name="Triangles   ">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} TRIS_CHUNK <read=TRIS_CHUNKread, name="TRIS Chunk   ">;

string TRIS_CHUNKread(TRIS_CHUNK &tris) {
    string  s;
    return SPrintf(s, "%d Triangles", numTriSurfTris);
}


// VVEC chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int       pos = FTell();
    ID              type<name="Type   ">;
    ulong           dimension<name="Dimension">;
    string          vectorName<name="Vector Name   ">;
    if (sizeof(vectorName) & 1)
        uchar padding <hidden=true>;
    struct vector {
        float   val[dimension];
    };
    while( FTell() - pos < size )
        vector         v;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} VVEC_CHUNK <read=VVEC_CHUNKread, name="VVEC Chunk   ">;
string VVEC_CHUNKread(VVEC_CHUNK &vvec) {
    string  s;
    return  SPrintf(s, "Type: %s   Name: %s   ", vvec.type, vvec.vectorName);
}


// TTGS chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    typedef struct {
        ID          type<name="Type   ">;
        string      value<name="Value   ">;
        if (sizeof(value) & 1)
            uchar padding <hidden=true>;
    }TSTAG;
    TSTAG           triSurfTags[numTriSurfTags]<optimize=false, name="Tag", read=TSTAGRead>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} TTGS_CHUNK <name="TTGS Chunk   ">;

string TSTAGRead(TSTAG &tag) {
    string s;
    return SPrintf(s, "Type: %s   Value: %s", tag.type, tag.value);
}


// AUTH chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    string          authorName<name="Author   ">;
    if (sizeof(authorName) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AUTH_CHUNK <read=AUTH_CHUNKread, name="AUTH Chunk   ">;

string AUTH_CHUNKread(AUTH_CHUNK &auth) {
    return auth.authorName;
}


// (c) chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    string          dateAndHolder<name="Date & Holder   ">;
    if (sizeof(dateAndHolder) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} CPYR_CHUNK <read=CPYR_CHUNKread, name="CPYR Chunk   ">;

string CPYR_CHUNKread(CPYR_CHUNK &cpyr) {
    return cpyr.dateAndHolder;
}


// ANNO chunk
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    string          annotation<name="Annotation   ">;
    if (sizeof(annotation) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ANNO_CHUNK <read=ANNO_CHUNKread, name="ANNO Chunk   ">;

string ANNO_CHUNKread(ANNO_CHUNK &anno) {
    return anno.annotation;
}


// AANI CHUNK
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    local int pos = FTell();
    local int subchunks = FTell();
    while( FTell() - pos < size )
        readAANIsubchunks(subchunks);
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AANI_CHUNK <name="ANNI Chunk   ">;


// BAKE CHUNK
typedef struct {
    ID              chunkID<name="Chunk ID   ">;
    CSIZE           size<name="Size">;
    ulong           refID<name="Ref ID">;
    ulong           samples<name="Samples">;
    float           starttime<name="Start Time">;
    float           samples_per_sec<name="Samples Per Sec">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} BAKE_CHUNK <name="BAKE Chunk   ">;


//------------------------------------------------------------
// Item subchunk definitions.
//------------------------------------------------------------

// LINK subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      graphName<name="Graph Name   ">;
    if (sizeof(graphName) & 1)
        uchar padding <hidden=true>;
    long        itemID<name="Item ID   ">;
    long        itemIndex<name="Item Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_LINK_SUBCHUNK <read=ITEM_LINK_SUBCHUNKread, name="LINK Subchunk   ">;

string ITEM_LINK_SUBCHUNKread(ITEM_LINK_SUBCHUNK &link) {
    string s;
    SPrintf(s, "Graph name: %s", link.graphName);
    return  s;
}


//enum <ushort> ENUM1{              // Item Data Types
//    LXItemType_Int              = 0x01,
//    LXItemType_Float            = 0x02,
//    LXItemType_String           = 0x03,
//    LXItemType_Variable         = 0x04,
//    LXItemType_Envelope         = 0x10,
//    LXItemType_UndefState       = 0x20,     // undefined action channel
//
//    LXItemType_EnvelopeInt      = LXItemType_Envelope | LXItemType_Int,
//    LXItemType_EnvelopeFloat    = LXItemType_Envelope | LXItemType_Float,
//    LXItemType_EnvelopeString   = LXItemType_Envelope | LXItemType_String,
//
//    LXItemType_FloatAlt         = 0x4e56,   // compatibility with some apps
//
//    LXEnvelopeType_Float        = 0,
//    LXEnvelopeType_Int          = 1,
//    };


// CHNL subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      chnlName<name="Channel Name   ">;
    // pad to even byteif needed
    if (sizeof(chnlName) & 1)
        uchar padding <hidden=true>;
    ushort       datatype<name="Datatype">;
    
    switch (datatype & ~LXItemType_UndefState) {
        case LXItemType_Int:
        case LXItemType_EnvelopeInt:
            long     data<name="Data">;
            break;
        case LXItemType_Float:
        case LXItemType_FloatAlt:
        case LXItemType_EnvelopeFloat:
            float   data<name="Data">;
            break;
        case LXItemType_String:
        case LXItemType_EnvelopeString:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNL_SUBCHUNK <name="CHNL Subchunk   ">;

string ITEM_CHNL_SUBCHUNKread(ITEM_CHNL_SUBCHUNK &chnl) {
    return chnl.chnlName;
}


// CHNS subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      chnlName<name="Channnel Name   ">;
    // pad to even byteif needed
    if (sizeof(chnlName) & 1)
        uchar padding <hidden=true>;
    string      chnlvalue<name="Channel Value   ">;
    // pad to even byteif needed
    if (sizeof(chnlvalue) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNS_SUBCHUNK <read=ITEM_CHNS_SUBCHUNKread, name="CHNS Subchunk   ">;

string ITEM_CHNS_SUBCHUNKread(ITEM_CHNS_SUBCHUNK &chns) {
    string s;
    return SPrintf(s, "%s: %s", chns.chnlName, chns.chnlvalue);
}


// CHNV subchunk
typedef struct {
    local int   start = FTell();
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    string      chnlName<name="Channel Name   ">;
    // pad to even byteif needed
    if (sizeof(chnlName) & 1)
        uchar padding <hidden=true>;
    short       datatype<name="Datatype">;
    short       elements<name="Elements">;

    struct {
        string      vectorname<name="Vector Name">;
        // pad to even byteif needed
        if (sizeof(vectorname) & 1)
            uchar padding <hidden=true>;

        switch (datatype & ~0x20) {
        case 1: 
            long     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        }
        }values[elements] <optimize=false>;


    // Deal with any unknown data at the end of the chunk
    if( size > (FTell() - pos) ){
        uchar unknown[ size - (FTell() - pos) ];
        Printf( "Encountered unknown data at end of '%s' subchunk. at position %Ld.\n", subchunkID, start );
        }
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNV_SUBCHUNK <read=ITEM_CHNV_SUBCHUNKread, name="CHNV Subchunk   ">;

string ITEM_CHNV_SUBCHUNKread(ITEM_CHNV_SUBCHUNK &chnv) {
    return chnv.chnlName;
}


// LAYR subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       index<name="Index">;
    ulong       flags<format=binary, name="Flags">;   //need to come back to these
    RGBA        wireColor<name="Wire Color">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_LAYR_SUBCHUNK <name="LAYR Subchunk   ">;


// UCHN subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    string          chanName<name="Channel Name   ">;
    // pad to even byteif needed
    if (sizeof(chanName) & 1)
        uchar padding <hidden=true>;
    string          chanType<name="Channel Type   ">;
    // pad to even byteif needed
    if (sizeof(chanType) & 1)
        uchar padding <hidden=true>;
    ulong           vecMode<name="Vector Mode">;  // come back to this
    ulong           flags<format=binary, name="Flags">; 
    long            defaultInt<name="Default Int">;
    float           defaultFloat<name="Default Float">;
    ushort          numHints<name="Num Hints">;
    if (numHints) {
        struct {
            string      hintName<name="Hint Name   ">;
            // pad to even byteif needed
            if (sizeof(hintName) & 1)
                uchar padding <hidden=true>;
            long        hintValue<name="Hint Value">;
        } hints[numHints] <optimize=false>;
    }

    // Deal with any unknown data at the end of the chunk
    if( size > (FTell() - pos) ){
        local int start = FTell();
        uchar unknown[ size - (start - pos) ];
        Printf( "Encountered unknown data at end of ITEM subchunk %s. at position %Ld.\n", subchunkID, start );
        }
    
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_UCHN_SUBCHUNK <read=ITEM_UCHN_SUBCHUNKread, name="UCHN Subchunk   ">;

string ITEM_UCHN_SUBCHUNKread(ITEM_UCHN_SUBCHUNK &uchn){
    return uchn.chanName;
}


// UNIQ subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      identifier<name="Identifier">;
    // pad to even byteif needed
    if (sizeof(identifier) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_UNIQ_SUBCHUNK <read=ITEM_UNIQ_SUBCHUNKread, name="UNIQ Subchunk   ">;

string ITEM_UNIQ_SUBCHUNKread(ITEM_UNIQ_SUBCHUNK &uniq) {
    string s;
    return SPrintf(s, "Unique Identifier: %s", uniq.identifier);
}


// ITAG subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ID          type<name="Tag Type">;
    string      value<name="Tag Value">;
    // pad to even byteif needed
    if (sizeof(value) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_ITAG_SUBCHUNK <read=ITEM_ITAG_SUBCHUNKread, name="ITAG Subchunk   ">;

string ITEM_ITAG_SUBCHUNKread(ITEM_ITAG_SUBCHUNK &itag) {
    string s;
    return SPrintf(s, "%s: %s", itag.type, itag.value);
}

// UIDX subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    long        index<name="Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_UIDX_SUBCHUNK <name="UIDX Subchunk   ">;


// GRAD subchunk

typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    string      channelName<name="Channel Name   ">;
    // pad to even byteif needed
    if (sizeof(channelName) & 1)
        uchar padding <hidden=true>;
    local ushort tmpIndex;
    tmpIndex = ReadUShort(FTell());
    if (tmpIndex < 0xFF00)
        ushort index<name="Index">;
    else
        ulong index<name="Index">;
    ulong   interpolationFlags<format=binary>; 
    if( size > (FTell() - pos) ){
    string      intype<name="In-Type   ">;
    // pad to even byteif needed
    if (sizeof(intype) & 1)
        uchar padding <hidden=true>;
    string      outtype<name="Out-Type   ">;
    // pad to even byteif needed
    if (sizeof(outtype) & 1)
        uchar padding <hidden=true>;
    }

    //    uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_GRAD_SUBCHUNK <read=ITEM_GRAD_SUBCHUNKread, name="GRAD Subchunk   ">;

string ITEM_GRAD_SUBCHUNKread(ITEM_GRAD_SUBCHUNK &grad){
    return grad.channelName;
}



// PAKG subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      name<name="Name   ">;
    // pad to even byteif needed
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    ulong       datasize<name="Datasize">;
    if (datasize > 0)
        uchar       data[datasize];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_PAKG_SUBCHUNK <read=ITEM_PAKG_SUBCHUNKread, name="PAKG Subchunk   ">;

string ITEM_PAKG_SUBCHUNKread(ITEM_PAKG_SUBCHUNK &pakg) {
    string s;
    return SPrintf(s, "Type: %s", pakg.name);
}


// CHAN Subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    local ushort    tmpIndex;
    tmpIndex = ReadUShort(FTell());
    if (tmpIndex < 0xFF00)
        ushort          channelIndex<name="Channel Index">;
    else
        ulong           channelIndex<name="Channel Index">;
    ushort          datatype<name="Datatype">;
    switch (datatype & ~0x20) {
        case 1: 
            int     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        case 17: 
            int     data<name="Data">;
            break;
        case 18:
            float   data<name="Data">;
            break;
        case 19:
            string      data<name="Data">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }

    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar value[ size - (FTell() - pos) ];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHAN_SUBCHUNK <name="CHAN Subchunk   ">;


// XREF subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       subsceneIndex<name="SubScene Index">;
    string      filename<name="Filename">;
    if (sizeof(filename) & 1)
        uchar padding <hidden=true>;
    string      itemIdentifier<name="Identifier">;
    if (sizeof(itemIdentifier) & 1)
        uchar padding <hidden=true>;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_XREF_SUBCHUNK <read=ITEM_XREF_SUBCHUNKread, name="XREF Subchunk   ">;

string ITEM_XREF_SUBCHUNKread(ITEM_XREF_SUBCHUNK &xref) {
    return xref.filename;
}


// CLNK subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string      graphName<name="Graph name   ">;
    if (sizeof(graphName) & 1)
        uchar padding <hidden=true>;
    string      fromChannel<name="From-Channel   ">;
    if (sizeof(fromChannel) & 1)
        uchar padding <hidden=true>;
    ulong       fromItemID<name="From-Item ID">;
    string      toName<name="To-Name   ">;
    if (sizeof(toName) & 1)
        uchar padding <hidden=true>;
    ulong       fromIndex<name="From-Index">;
    ulong       toIndex<name="To-Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CLNK_SUBCHUNK <read=ITEM_CLNK_SUBCHUNKread, name="CLNK Subchunk   ">;

string ITEM_CLNK_SUBCHUNKread(ITEM_CLNK_SUBCHUNK &clnk) {
    string s;
    SPrintf(s, "Graph: %s   From: %s   To: %s", clnk.graphName, clnk.fromChannel, clnk.toName);
    return  s;
}


// PRVW subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    unsigned short  width<name="Width">;
    unsigned short  height<name="Height">;
    unsigned long   type<name="Type">;
    unsigned long   flags<format=binary, name="Flags">; 
    char    previewData[size - (FTell() - pos)]<name="Preview Data   ">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_PRVW_SUBCHUNK <read=ITEM_PRVW_SUBCHUNKread, name="PRVW Subchunk   ">;

string ITEM_PRVW_SUBCHUNKread(ITEM_PRVW_SUBCHUNK &prvw) {
    string s;
    return SPrintf(s, "width: %d height: %d", prvw.width, prvw.height);
}


// BBOX chunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    POINT       min;
    POINT       max;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_BBOX_SUBCHUNK <read=ITEM_BBOX_SUBCHUNKRead, name="BBOX Subchunk   ">;

string ITEM_BBOX_SUBCHUNKRead(ITEM_BBOX_SUBCHUNK &bbox) {
    string s;
    return SPrintf( s, "(%s), (%s)", POINT_Read(bbox.min), POINT_Read(bbox.max) );
}

// CHNC chunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    uchar        data[size];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ITEM_CHNC_SUBCHUNK <name="CHNC Subchunk   ">;



//------------------------------------------------------------
// ENVL subchunk definitions.
//------------------------------------------------------------

// PRE subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ushort      behaviour<name="Behaviour">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_PRE_SUBCHUNK <read=PRE_Behaviour, name="PRE Subchunk">;

string PRE_Behaviour(ENVL_PRE_SUBCHUNK &chunk) {
    switch(chunk.behaviour){
        case 0: return "Reset";
        case 1: return "Constant";
        case 2: return "Repeat";
        case 3: return "Oscillate";
        case 4: return "Offset Repeat";
        case 5: return "Linear";
        case 6: return "None";
    }
}


// POST subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ushort      behaviour<name="Behaviour">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_POST_SUBCHUNK <read=POST_Behaviour, name="POST Subchunk   ">;

string POST_Behaviour(ENVL_POST_SUBCHUNK &chunk) {
    switch(chunk.behaviour){
        case 0: return "Reset";
        case 1: return "Constant";
        case 2: return "Repeat";
        case 3: return "Oscillate";
        case 4: return "Offset Repeat";
        case 5: return "Linear";
        case 6: return "None";
    }
}


// KEY subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    float       time<name="Time">;
    float       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_KEY_SUBCHUNK <read=KEY_Value, name="KEY Subchunk   ">;

string KEY_Value(ENVL_KEY_SUBCHUNK &chunk){
    string s;
    return SPrintf(s, "%f", chunk.value);
}


// IKEY subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    float       time<name="Time">;
    ulong       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_IKEY_SUBCHUNK <read=IKEY_Value, name="IKEY Subchunk   ">;

string IKEY_Value(ENVL_IKEY_SUBCHUNK &chunk){
    string s;
    return SPrintf(s, "%f", chunk.value);
}


// TANI subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ushort      slopeType<name="Slope Type">;
    ushort      weightType<name="Weight Type">;
    float       weight<name="Weight">;
    float       slope<name="Slope">;
    float       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_TANI_SUBCHUNK<name="TANI Subchunk   ">;


// TANO subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       breaks<name="Breaks">;
    ushort      slopeType<name="Slope Type">;
    ushort      weightType<name="Weight Type">;
    float       weight<name="Weight">;
    float       slope<name="Slope">;
    float       value<name="Value">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_TANO_SUBCHUNK<name="TANO Subchunk   ">;


// FLAG subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       flags<format=binary, name="Flags">; 

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ENVL_FLAG_SUBCHUNK <read=FLAG_Read, name="FLAG Subchunk   ">;

string FLAG_Read(ENVL_FLAG_SUBCHUNK &chunk){
    return "Deprecated";
}



//------------------------------------------------------------
// ACTN subchunk definitions.
//------------------------------------------------------------

// ITEM subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       identifier<name="Identifier">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_ITEM_SUBCHUNK<name="ITEM Subchunk   ">;


// GRAD subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local int       pos = FTell();
    local ushort    tmpChnlNameIdx;
    tmpChnlNameIdx = ReadUShort(FTell());
    if (tmpChnlNameIdx < 0xFF00)
        ushort      nameIndex<name="Channel Name Index">;
    else
        ulong       nameIndex<name="Channel Name Index">;
    local ushort    tmpEnvlIdx;
    tmpEnvlIdx = ReadUShort(FTell());
    if (tmpEnvlIdx < 0xFF00)
        ushort  envelopeIndex<name="Envelope Index">;
    else
        ulong   envelopeIndex<name="Envelope Index">;
    ulong   flags<format=binary>; 
    if (size > 8) {
    string          name<name="Name   ">;
    // pad to even byteif needed
    if (sizeof(name) & 1)
        uchar padding <hidden=true>;
    if( size > (FTell() - pos) ){
        string  intype<name="In-Type   ">;
        // pad to even byteif needed
        if (sizeof(intype) & 1)
            uchar padding <hidden=true>;
        string  outtype<name="Out-Type   ">;
        // pad to even byteif needed
        if (sizeof(outtype) & 1)
            uchar padding <hidden=true>;
    }
}
    //    uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_GRAD_SUBCHUNK<read=ACTN_GRAD_SUBCHUNKread, name="GRAD Subchunk   ">;

string ACTN_GRAD_SUBCHUNKread(ACTN_GRAD_SUBCHUNK &grad) {
    return grad.name;
}


// PRNT subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    ulong       identifier<name="Identifier">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_PRNT_SUBCHUNK<name="PRNT Subchunk   ">;


// CHAN subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    local ushort    tmpChnlNameIdx;
    tmpChnlNameIdx = ReadUShort(FTell());
    if (tmpChnlNameIdx < 0xFF00)
        ushort      nameIndex<name="Channel Name Index">;
    else
        ulong       nameIndex<name="Channel Name Index">;
    ushort          datatype<name="Datatype">;  
    local ushort    tmpEnvlIdx;
    if (tmpEnvlIdx < 0xFF00)
        ushort      envelopeIndex<name="Envelope Index">;
    else
        ulong       envelopeIndex<name="Envelope Index">;
    switch (datatype & ~0x20) {
        case 1: 
            int     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data  ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        case 17: 
            int     data<name="Data">;
            break;
        case 18:
            float   data<name="Data">;
            break;
        case 19:
            string      data<name="Data">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }


    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHAN_SUBCHUNK<name="CHAN Subchunk   ">;


// CHNS subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    string          channelName<name="Channel Name">;
    // pad to even byteif needed
    if (sizeof(channelName) & 1)
        uchar padding <hidden=true>;
    local ushort    tmpChnlIdx;
    tmpChnlIdx = ReadUShort(FTell());
    if (tmpChnlIdx < 0xFF00)
        ushort  channelIndex<name="Channel Index">;
    else
        ulong   channelIndex<name="Channel Index">;
    string          value<name="Value  ">;
    // pad to even byteif needed
    if (sizeof(value) & 1)
        uchar padding <hidden=true>;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHNS_SUBCHUNK<read=ACTN_CHNS_SUBCHUNKread, name="CHNS Subchunk   ">;

string ACTN_CHNS_SUBCHUNKread(ACTN_CHNS_SUBCHUNK &chns) {
    string s;
    return SPrintf(s, "Name: %s   Value: %s", chns.channelName, chns.value);
}


// CHNN subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    string          channelName<name="Channel Name  ">;
    // pad to even byteif needed
    if (sizeof(channelName) & 1)
        uchar padding <hidden=true>;
    ushort          datatype<name="DataType">;
    local ushort    tmpEnvlIdx;
    tmpEnvlIdx = ReadUShort(FTell());
    if (tmpEnvlIdx < 0xFF00)
        ushort  envelopeIndex<name="Envelope Index">;
    else
        ulong   envelopeIndex<name="Envelope Index">;
    switch (datatype) {
        case 1: 
            int     data<name="Data">;
            break;
        case 2: 
            float   data<name="Data">;
            break;
        case 3:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
        case 17: 
            int     data<name="Data">;
            break;
        case 18:
            float   data<name="Data">;
            break;
        case 19:
            string      data<name="Data   ">;
            if (sizeof(data) & 1)
                uchar padding <hidden=true>;
            break;
    }

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} ACTN_CHNN_SUBCHUNK<read=ACTN_CHNN_SUBCHUNKread, name="CHNN Subchunk   ">;

string ACTN_CHNN_SUBCHUNKread(ACTN_CHNN_SUBCHUNK &chnn){
    return chnn.channelName;
}


//------------------------------------------------------------
// AANI subchunk definitions.
//------------------------------------------------------------

// AAIT subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    ulong           itemrefindex<name="Item Ref Index">;

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AANI_AAIT_SUBCHUNK<name="AAIT Subchunk   ">;


// AASE subchunk
typedef struct {
    ID              subchunkID<name="Subchunk ID">;
    SCSIZE          size<name="Subchunk Size">;
    ushort          loopmode<name="Loop Mode">;
    ushort          mutestate<name="Mute State">;
    ushort          scrubstate<name="Scrub State">;
    float           starttime<name="Start Time">;
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} AANI_AASE_SUBCHUNK<name="AANI Subchunk   ">;



//------------------------------------------------------------
// REFS subchunk definitions.
//------------------------------------------------------------

// IDEL subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    ulong           index<name="Index">;
    
    string          refname<name="Ref Name">;
    // pad to even byteif needed
    if (sizeof(refname) & 1)
        uchar padding <hidden=true>;
    string          parentname<name="Parent Name">;
    // pad to even byteif needed
    if (sizeof(parentname) & 1)
        uchar padding <hidden=true>;
    typedef struct {
        string  refstring<name="Reference">;
        if (sizeof(refstring) & 1)
            uchar padding <hidden=true>;
    } REFSTRING <read=REFSTRING_Read>;

    while( FTell() - pos < size )
        REFSTRING  item;
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} REFS_IDEL_SUBCHUNK<name="REFS Subchunk   ">;

string REFSTRING_Read(REFSTRING &item) {
    return item.refstring;
}


// LOPT subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    local int pos = FTell();
    // Unknown data at the end of the chunk
    if( size > (FTell() - pos) )
        uchar unknown[ size - (FTell() - pos) ];
    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} REFS_LOPT_SUBCHUNK<name="LOPT Subchunk   ">;



//------------------------------------------------------------
// catchall for chunks/subchunks we don't recognize
//------------------------------------------------------------
typedef struct {
    ID          subchunkID<name="Chunk ID">;
    SCSIZE      size<name="Chunk Size">;
    uchar     unknownData[size];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} UNKNOWNCHUNK<name="Unknown Chunk">;


// unknown subchunk
typedef struct {
    ID          subchunkID<name="Subchunk ID">;
    SCSIZE      size<name="Subchunk Size">;
    uchar       unknownData[size];

    // Padding so the next chunk starts on an even byte
    if( (size & 1) && (FTell() < FileSize()) )
        uchar padding <hidden=true>;
} UNKNOWNSUBCHUNK<name="Unknown Subchunk">;



//------------------------------------------------------------
// misc utility data structures
//------------------------------------------------------------

// RGBA color
typedef struct {
    unsigned char R;
    unsigned char G;
    unsigned char B;
    unsigned char A;
} RGBA<name="RGBA">;


// point/vertex coordinate
typedef struct {
    float   X;
    float   Y;
    float   Z;
} POINT <read=POINT_Read, name="Point">;

string POINT_Read(POINT &point){
    string s;
    SPrintf(s, "X: %f, Y: %f, Z: %f", point.X, point.Y, point.Z);
    return s;
}


//used by VMAD and VMED chunks
typedef struct {
        local ushort tmpIndex;
        tmpIndex = ReadUShort(FTell());
        if (tmpIndex < 0xFF00)
            ushort  indexInPNTS;
        else
            ulong   indexInPNTS;
        local ushort tmpIndex2;
        tmpIndex2 = ReadUShort(FTell());
        if (tmpIndex2 < 0xFF00)
            ushort  indexSharedPoly;
        else
            ulong   indexSharedPoly;
        if (dimension > 0)
            float           values[dimension];
    } VERTDATA<name="Vertex Data">;



//------------------------------------------------------------
// subchunk reading functions
//------------------------------------------------------------

void readITEMsubchunks(int pos){
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );

    // See which chunk this is
    switch( tag )
    {
        case "LINK":
            ITEM_LINK_SUBCHUNK LINK;
            break;
        case "CHNL":
            ITEM_CHNL_SUBCHUNK CHNL;
            break;
        case "CHNS":
            ITEM_CHNS_SUBCHUNK CHNS;
            break;
        case "CHNV":
            ITEM_CHNV_SUBCHUNK CHNV;
            break;
        case "UNIQ":
            ITEM_UNIQ_SUBCHUNK UNIQ;
            break;
        case "UIDX":
            ITEM_UIDX_SUBCHUNK UIDX;
            break;
        case "LAYR":
            ITEM_LAYR_SUBCHUNK LAYR;
            break;
        case "UCHN":
            ITEM_UCHN_SUBCHUNK UCHN;
            break;
        case "ITAG":
            ITEM_ITAG_SUBCHUNK ITAG;
            break;
        case "GRAD":
            ITEM_GRAD_SUBCHUNK GRAD;
            break;
        case "PAKG":
            SetBackColor( cLtGreen );
            ITEM_PAKG_SUBCHUNK   PAKG;
            break;
        case "CHAN":
            SetBackColor( cLtGreen );
            ITEM_CHAN_SUBCHUNK   CHAN;
            break;
        case "XREF":
            SetBackColor( cLtGreen );
            ITEM_XREF_SUBCHUNK   XREF;
            break;
        case "CLNK":
            SetBackColor( cLtGreen );
            ITEM_CLNK_SUBCHUNK   CLNK;
            break;
        case "PRVW":
            SetBackColor( cPurple );
            ITEM_PRVW_SUBCHUNK  PRVW;
            break;
        case "BBOX":
            SetBackColor( cPurple );
            ITEM_BBOX_SUBCHUNK  BBOX;
            break;
        case "CHNC":
            SetBackColor( cGreen );
            ITEM_CHNC_SUBCHUNK  CHNC;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown ITEM subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void readENVLsubchunks(int pos){
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );

    // See which chunk this is
    switch( tag )
    {
        case "PRE ":
            ENVL_PRE_SUBCHUNK PRE;
            break;
        case "POST":
            ENVL_POST_SUBCHUNK POST;
            break;
        case "KEY ":
            ENVL_KEY_SUBCHUNK KEY;
            break;
        case "IKEY":
            ENVL_IKEY_SUBCHUNK IKEY;
            break;
        case "TANI":
            ENVL_TANI_SUBCHUNK TANI;
            break;
        case "TANO":
            ENVL_TANO_SUBCHUNK TANO;
            break;
        case "FLAG":
            ENVL_FLAG_SUBCHUNK FLAG;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown ENVL subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void readACTNsubchunks(int pos){
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );
    // See which chunk this is
    switch( tag )
    {
        case "ITEM":
            ACTN_ITEM_SUBCHUNK ITEM;
            break;
        case "GRAD":
            ACTN_GRAD_SUBCHUNK GRAD;
            break;
        case "PRNT":
            ACTN_PRNT_SUBCHUNK PRNT;
            break;
        case "CHAN":
            ACTN_CHAN_SUBCHUNK CHAN;
            break;
        case "CHNS":
            ACTN_CHNS_SUBCHUNK CHNS;
            break;
        case "CHNN":
            ACTN_CHNN_SUBCHUNK CHNN;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown ACTN subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void readAANIsubchunks(int pos){
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );

    // See which chunk this is
    switch( tag )
    {
        case "AAIT":
            AANI_AAIT_SUBCHUNK AAIT;
            break;
        case "AASE":
            AANI_AASE_SUBCHUNK AASE;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown AANI subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


void readREFSsubchunks(int pos){
    local ID tag;
    local uint size;
    ReadBytes( tag, FTell(), 4 );

    // See which chunk this is
    switch( tag )
    {
        case "IDEL":
            REFS_IDEL_SUBCHUNK IDEL;
            break;
        case "LOPT":
            REFS_LOPT_SUBCHUNK LOPT;
            break;
        default:
            size = ReadUInt( FTell()+4 );
            Printf( "Encountered unknown REFS subchunk '%s' of size %d at position %Ld.\n", tag, size, FTell() );
            UNKNOWNSUBCHUNK unknown;
            break;
        }
}


